package tvmHandler

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/laminafinance/crosschain-api/pkg/utils"

	//cell "github.com/xssnick/tonutils-go/tvm/cell"
	//tlb "github.com/xssnick/tonutils-go/tl"
	//cell "github.com/xssnick/tonutils-go/ton"
	"github.com/xssnick/tonutils-go/tvm/cell"
)

// still need to the params struct for the inital call
// the protocol calling the client (rest etc) will be providing the actual call to be made
// the call will be in the format ProxyMessageRaw (essentially letting the call decide the value, to, and body)

// this means we need to have a test body

// we need to be able to convert the transaction input into a BoC
// so the user says a to, value, body
// we convert that data to a hash (this specifies the target but not that wallet or nonce, could be double spent)

// we need to reflect the op, data, hash, and value to be locked

// the escrow will be empty

// normally this is generated by the wallet
// our client will verify the gas
// no proxy wallet init required (supposedly), I think we need to evaluate this is true but later
// for now we have the init generation in the op

/**

need to create this function in golang
slice calculate_user_proxy_wallet_address(int evm_address, slice entrypoint_address, cell proxy_wallet_code) inline {
  return calculate_proxy_wallet_address(calculate_proxy_wallet_state_init(evm_address, entrypoint_address, proxy_wallet_code));
}

then this
slice calculate_proxy_wallet_address(cell state_init) inline {
  return begin_cell().store_uint(4, 3)
                     .store_int(workchain, 8)
                     .store_uint(cell_hash(state_init), 256)
                     .end_cell()
                     .begin_parse();
}

then we need to build a message to this with state_init code
cell calculate_proxy_wallet_state_init(int evm_address, slice entrypoint_address, cell proxy_wallet_code) inline {
  return begin_cell()
          .store_uint(0, 2)
          .store_dict(proxy_wallet_code)
          .store_dict(pack_proxy_wallet_data(0, evm_address, entrypoint_address, proxy_wallet_code))
          .store_uint(0, 1)
         .end_cell();
}



*/

func packProxyWalletData(nonce int, ownerEvmAddress int, entrypointAddress *cell.Cell) *cell.Cell {
	c := cell.BeginCell().
		MustStoreBigUInt(big.NewInt(int64(nonce)), 64)
	entrypointBytes := entrypointAddress.ToBOC()
	c.StoreSlice(entrypointBytes, uint(len(entrypointBytes)*8))
	c.StoreUInt(uint64(ownerEvmAddress), 160)
	c.StoreSlice([]byte{}, 0)
	return c.EndCell()
}

func calculateProxyWalletStateInit(evmAddress int, entrypointAddress *cell.Cell, proxyWalletCode *cell.Dictionary) *cell.Cell {
	c := cell.BeginCell()
	c.StoreUInt(0, 2)
	c.StoreDict(proxyWalletCode)
	proxyWalletData := packProxyWalletData(0, evmAddress, entrypointAddress)
	c.StoreDict(proxyWalletData.BeginParse().MustLoadDict(256))
	c.StoreUInt(0, 1)
	return c.EndCell()
}

func calculate_proxy_wallet_address(state_init *cell.Cell, workchain int) *cell.Slice {
	// Generate the proxy wallet address using the state_init and workchain
	return cell.BeginCell().
		StoreUInt(4, 3).
		storeI(workchain, 8).                  // Store the workchain id (usually 0 for the main network).
		StoreUInt(cell.Hash(state_init), 256). // Store the hash of the state_init cell.
		EndCell().
		BeginParse() /// needs top be fix
}

// the proxy wallet is essentially data loaded from a storage contract onto the main proxy contract
func GenerateTestTvmOperation() PackedUserOperation {
	return PackedUserOperation{
		InitCode: []byte{}, // fkin garabage we need to initialize seperately
		// this means I literally need to rewrite our func contracts, fk fkkity fk
		Sender:             common.Address{},
		Nonce:              big.NewInt(0),
		InitCode:           []byte{},
		CallData:           []byte{},
		AccountGasLimits:   [32]byte{},
		PreVerificationGas: big.NewInt(20000000),
		GasFees:            [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
		PaymasterAndData:   []byte{},
		Signature:          []byte{},
	}
}

// need rts/lts on ton via

// both need to be fixed
type MessageEscrowTvm struct {
	EscrowAddress   string `json:"eaddress"`
	EscrowInit      string `json:"einit"`
	EscrowPayload   string `json:"epayload"`
	EscrowAsset     string `json:"easset"`
	EscrowAmount    string `json:"eamount"`
	EscrowValueType string `json:"evaluetype"`
	EscrowValue     string `json:"evalue"`
}

type MessageOpTvm struct {
	UserOp           PackedUserOperationResponse `json:"op-packed-data"` // parsed data, recommended to validate data
	PaymasterAndData PaymasterAndDataResponse    `json:"op-paymaster"`
	UserOpHash       string                      `json:"op-hash"`
	PriceGwei        string                      `json:"op-price"`
}

type UnsignedEscrowRequestParams struct {
	Header utils.PartialHeader `query:"header"`
	Escrow EscrowLockParams    `query:"escrow"`
}

type UnsignedEntryPointRequestParams struct {
	Header       utils.MessageHeader `query:"header"`
	ProxyInit    ProxyInitParams     `query:"proxy-wallet"`
	ProxyMessage ProxyMessageRaw     `query:"msg" optional:"true"`
} // might not need init, investigating calculation of target proxy

type ProxyInitParams struct {
	Nonce           string `query:"nonce" optional:"true"`
	EntryPoint      string `query:"entrypoint" optional:"true"` // we need to dtermine this or fetch from the backend
	PayeeAddress    string `query:"payee-address" optional:"true"`
	OwnerEvmAddress string `query:"evm-address"`
	OwnerTvmAddress string `query:"tvm-address" optional:"true"`
}

type ProxyInitResponse struct {
}

type EscrowLockParams struct {
	SignerAddress string `query:"signer-address"`
	AdminAddress  string `query:"admin-address" optional:"true"`
	PayeeAddress  string `query:"payee-address" optional:"true"`
	Id            string `query:"id" optional:"true"`
	Value         string `query:"value" optional:"true"`
}

// message directly to entrypoint
type ExternalMessageRaw struct {
	Via      string `json:"via"` // the solver sender (the backend)
	Value    string `json:"value"`
	SendMode string `json:"send-mode"`
	Body     string `json:"body"`
}

type EntryPointMessageRaw struct {
	Destination string                  `json:"proxy-wallet"`
	QueryId     string                  `json:"query-id"` // kinda pointless atm
	Message     MessageToProxyWalletRaw `json:"proxy-message"`
}

type MessageToProxyWalletRaw struct {
	QueryId  string          `json:"msg-id"` // no security but used for onchain hash
	Sigature SignatureRaw    `json:"msg-sig"`
	Data     ProxyMessageRaw `json:"msg-data"`
}

type SignatureRaw struct {
	V string `query:"v"` // tvm is often a garbage value at least from ts
	R string `query:"r"`
	S string `query:"s"`
}

type ProxyMessageRaw struct {
	Regime      string `query:"msg-regime"` // optional, set to 0 by default, apparently 0 or 1
	Destination string `query:"msg-to"`     // required
	Value       string `query:"msg-value"`  // required
	Body        string `query:"msg-body"`   // required
}

/*
// because of how the message headers operate it means we need to store in our db the users:
	 ton address, evm address, and escrow address for any chains (this will speed up development but up-cost)
type PartialHeader struct {
	TxType      string `query:"txtype"`               // for now just type1 tx and type0 (legacy)
	ChainName   string `query:"name" optional:"true"` // add later for QoL
	ChainType   string `query:"type" optional:"true"` // add later for QoL
	ChainId     string `query:"id"`
	ChainSigner string `query:"signer"`
}

type MessageHeader struct {
	TxType          string `query:"txtype"`                // for now just type1 tx and type0 (legacy)
	FromChainName   string `query:"fname" optional:"true"` // add later for QoL
	FromChainType   string `query:"ftype" optional:"true"` // add later for QoL
	FromChainId     string `query:"fid"`
	FromChainSigner string `query:"fsigner"`
	ToChainName     string `query:"tname" optional:"true"` // add later for QoL
	ToChainType     string `query:"ttype" optional:"true"` // add later for QoL
	ToChainId       string `query:"tid"`
	ToChainSigner   string `query:"tsigner"`
}
*/
